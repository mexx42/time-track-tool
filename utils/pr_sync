#!/usr/bin/python

from __future__ import print_function
from __future__ import absolute_import

import os
import xmlrpclib
from   datetime          import datetime
from   rsclib.autosuper  import autosuper
from   rsclib.pycompat   import text_type
from   roundup           import instance
from   roundup.date      import Date

def date_from_xml (s) :
    assert s.startswith ('<Date ')
    assert s.endswith   ('>')
    s = s [6:-1]
    s = s.replace (' ', '.')
    return Date (s)
# end def date_from_xml

class PR_Sync (autosuper) :
    """ Sync Time-Tracker data from remote time tracker vie XMLRPC.
    """

    property_classes = dict \
        (( ('cost_center.cost_center_group', 'cost_center_group')
         , ('cost_center.status',            'cost_center_status')
         , ('cost_center_group.responsible', 'user')
         , ('department.part_of',            'department')
         , ('org_location.organisation',     'organisation')
         , ('org_location.location',         'location')
         , ('time_project.cost_center',      'cost_center')
         , ('time_project.department',       'department')
         , ('time_project.deputy',           'user')
         , ('time_project.nosy',             'user')
         , ('time_project.organisation',     'organisation')
         , ('time_project.responsible',      'user')
         , ('time_project.status',           'time_project_status')
         , ('user.department',               'department')
         , ('user.org_location',             'org_location')
         , ('user.status',                   'user_status')
        ))

    def __init__ (self, url, dir = None, user = 'admin') :
        self.srv       = xmlrpclib.ServerProxy (url, allow_none = True)
        dir            = dir or os.getcwd ()
        tracker        = instance.open (dir)
        self.db        = tracker.open (user)
        self.classname = None
        self.idmap     = {}
        self.pendmap   = {}
        self.now       = Date ('.')
        self.uvalid    = None
        self.obsolete  = None
        self.tc_open   = None
    # end def __init__

    def sync (self) :
        self.sync_class ('organisation', ('name', 'description'))
        self.sync_class ('location',     ('name', 'country'))
        self.sync_class ('org_location', ('name', 'location', 'organisation'))
        self.sync_pending ()
        self.sync_class \
            ('cost_center_status', ('name', 'description', 'active'))
        self.sync_class \
            ( 'cost_center_group'
            , ('name', 'description', 'active', 'responsible')
            )
        self.sync_class \
            ( 'cost_center'
            , ('name', 'description', 'status', 'cost_center_group')
            )
        self.sync_class ('department', ('name', 'description', 'part_of'))
        self.sync_class \
            ('time_project_status', ('name', 'description', 'active'))
        # only once at beginning?
        self.sync_class \
            ( 'user_status'
            , ('name', 'description', 'is_nosy', 'ldap_group', 'roles')
            )
        self.sync_class \
            ( 'user'
            , ( 'username', 'address', 'alternate_addresses', 'department'
              , 'org_location', 'realname', 'status'
              )
            , key = 'username'
            )
        self.sync_class \
            ( 'time_project'
            , ( 'name', 'cost_center', 'department', 'deputy', 'description'
              , 'organisation', 'responsible', 'status'
              )
            , required = ('cost_center', 'responsible')
            )

        self.sync_pending ()
        self.db.commit ()
    # end def sync

    # Check methods that check if a class item is valid
    def check_organisation (self, item) :
        d = item ['valid_to']
        if d :
            d = date_from_xml (d)
        return not d or d > self.now
    # end def check_organisation
    check_department = check_organisation

    def check_time_project (self, item) :
        if not self.tc_open :
            self.tc_open = self.db.time_project_status.lookup ('Open')
        if item ['status'] != self.tc_open :
            return False
        return bool (item ['op_project'])
    # end def check_time_project

    def check_user (self, user) :
        if user ['username'] in ('admin', 'anonymous') :
            return True
        if not self.uvalid :
            self.uvalid = self.srv.lookup ('user_status', 'valid')
        return user ['status'] == self.uvalid
    # end def check_user

    def fix_prop (self, value) :
        if isinstance (value, text_type) :
            return value.encode ('utf-8')
        return value
    # end def fix_prop

    def getpropclass (self, prop) :
        cn = self.classname
        return self.property_classes.get ('%s.%s' % (cn, prop), None)
    # end def getpropclass

    def map_id (self, prop, value) :
        if value is None :
            return None
        return self.idmap [self.getpropclass (prop)][value]
    # end def map_id

    def sync_class (self, classname, propnames, key = 'name', required = ()) :
        print ('Syncing: %s' % classname)
        assert key in propnames
        for r in required :
            assert r in propnames
        self.classname = classname
        cls = self.db.getclass (classname)
        self.idmap [classname] = {}
        mapped     = {}
        nonmapped  = {}
        pending    = {}
        for p in propnames :
            pkey = self.getpropclass (p)
            if pkey :
                if pkey in self.idmap and pkey != classname :
                    mapped [p] = 1
                else :
                    pending [p] = 1
            else :
                nonmapped [p] = 1
        if pending :
            self.pendmap [classname] = {}
        for id in self.srv.filter (classname, None, {}) :
            item = self.srv.display (classname + id)
            valid = True
            check = getattr (self, 'check_' + classname, None)
            if check :
                valid = check (item)
            lid = None
            try :
                lid = cls.lookup (self.fix_prop (item [key]))
            except KeyError :
                pass
            if valid :
                print ("Syncing: %s%s %s" % (classname, id, item))
                if not lid :
                    params = dict \
                        ( (k, self.fix_prop (item [k]))
                          for k in nonmapped if item [k] is not None
                        )
                    for k in mapped :
                        try :
                            v = self.map_id (k, item [k])
                        except KeyError :
                            print \
                                ( "WARN: Not in map: %s %s:%s"
                                % (classname, k, item [k])
                                )
                            v = None
                        if v is None :
                            continue
                        params [k] = v
                    for r in required :
                        if r not in params :
                            print ("WARN: Not in params: %s" % r)
                            break
                    else :
                        print ("Create: %s %s" % (classname, params))
                        lid = cls.create (** params)
                else :
                    litem = cls.getnode (lid)
                    d = {}
                    for p in nonmapped :
                        ritem = self.fix_prop (item [p])
                        if ritem != litem [p] :
                            d [p] = ritem
                    for p in mapped :
                        v = self.map_id (p, item [p])
                        if v != litem [p] :
                            d [p] = v
                    if (d) :
                        print ("Set: %s%s %s" % (classname, lid, d))
                        cls.set (lid, ** d)
                self.idmap [classname][id] = lid
                if pending :
                    self.pendmap [classname][lid] = dict \
                        ((k, item [k]) for k in pending if item [k] is not None)
            elif lid :
                if classname != 'user' :
                    print ("Retire: %s%s" % (classname, lid))
                    cls.retire (lid)
                else :
                    print ("Marking obsolete: %s%s" % (classname, lid))
                    if not self.obsolete :
                        self.obsolete = self.db.user_status.lookup ('obsolete')
                    cls.set (lid, status = self.obsolete)
    # end def sync_class

    def sync_pending (self) :
        for cn in self.pendmap :
            self.classname = cn
            cls = self.db.getclass (cn)
            for lid, props in self.pendmap [cn].iteritems () :
                d = dict \
                    ((k, self.map_id (k, v)) for k, v in props.iteritems ())
                if d :
                    print ("Set: %s%s %s" % (cn, lid, d))
                    cls.set (lid, ** d)
        self.pendmap = {}
    # end def sync_pending

# end class PR_Sync

if __name__ == '__main__' :
    import sys
    sync = PR_Sync (sys.argv [1])
    sync.sync ()
